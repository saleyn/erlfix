<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
<xsl:output method="text" media-type="text/plain" encoding="us-ascii"/>

<xsl:param name="now"/>
<xsl:param name="email">saleyn@gmail.com</xsl:param>

<xsl:template name="pad">
	<xsl:param name="padChar" select="' '"/>
    <xsl:param name="padCount" select="0"/>
    <xsl:value-of select="$padChar"/>
    <xsl:if test="$padCount &gt; 1">
		<xsl:call-template name="pad">
			<xsl:with-param name="padCount" select="number($padCount) - 1"/>
			<xsl:with-param name="padChar" select="$padChar"/>
		</xsl:call-template>
	</xsl:if>
</xsl:template>

<xsl:template name="arg-value">
	<xsl:param name="value"/>
	<xsl:param name="type"/>
	<xsl:choose>
		<xsl:when test="$type='INT'">"<xsl:value-of select="$value"/>"</xsl:when>
		<xsl:when test="$type='STRING'">"<xsl:value-of select="$value"/>"</xsl:when>
		<xsl:when test="$type='BOOLEAN'">$<xsl:value-of select="$value"/></xsl:when>
		<xsl:when test="$type='CHAR'">$<xsl:value-of select="$value"/></xsl:when>
		<xsl:when test="$type='MULTIPLEVALUESTRING'">$<xsl:value-of select="$value"/></xsl:when>
		<xsl:otherwise><xsl:value-of select="$value"/></xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template name="value-len">
	<xsl:param name="value"/>
	<xsl:param name="type"/>
	<xsl:choose>
		<xsl:when test="$type='INT'"><xsl:value-of select="string-length($value)+6"/></xsl:when>
		<xsl:when test="$type='STRING'"><xsl:value-of select="string-length($value)+6"/></xsl:when>
		<xsl:when test="$type='CHAR'"><xsl:value-of select="string-length($value)+5"/></xsl:when>
		<xsl:when test="$type='BOOLEAN'"><xsl:value-of select="string-length($value)+5"/></xsl:when>
		<xsl:when test="$type='MULTIPLEVALUESTRING'"><xsl:value-of select="string-length($value)+5"/></xsl:when>
		<xsl:otherwise><xsl:value-of select="string-length($value)"/></xsl:otherwise>
	</xsl:choose>
</xsl:template>

<xsl:template name="proper-case">
	<xsl:param name="str"/>
	<xsl:value-of select="concat(translate(substring($str, 1, 1),
		'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), substring($str, 2))"/>
</xsl:template>

<xsl:template match="/">%%%----------------------------------------------------------------------------
%%% @doc FIX Protocol Parser.
%%% @author Serge Aleynikov &lt;<xsl:value-of select="$email"/>&gt;
%%% @copyright 2011 Serge Aleynikov
%%% @end
%%%----------------------------------------------------------------------------
%%% Created: <xsl:value-of select="$now" />
%%%----------------------------------------------------------------------------
%%% This file is automatically generated!  Don't modify by hand!
%%%----------------------------------------------------------------------------
-module(fix_parse).
-author('<xsl:value-of select="$email"/>').

%% API
-export([
      decode/1, full_decode/1    
    , encode_msg_type/1, decode_msg_type/1
    , decode_field/1, encode_field/1, decode_value/2
]).

-include("fix_parse.hrl").
<xsl:text disable-output-escaping="yes">
%% @spec (FixFields) -&gt; #fix{}
%% @doc Decode FIX message from a list of fields
full_decode(FixFields) -&gt;
    Msg  = decode(FixFields),
    Body = [{element(1, decode_field(I)), decode_value(I, V)}
        || {I,V} &lt;- element(tuple_size(Msg#fix.body), Msg#fix.body)],
    Msg#fix{body = Body}.
    
%% @spec ([{Field::integer(), Value::binary()}]) -&gt; #fix{}
%% @doc Decode FIX message from a list of fields
decode([{8,&lt;&lt;"FIX.",V1,$.,V2>>},_,{35,&lt;&lt;I>>}|Fields]) -&gt;
	fill_header(#fix{version = (V1-$0)*10+(V2-$0),
	                 msgType=I}, Fields).

fill_header(Msg, [{34,B} | Tail]) -&gt;
    fill_header(Msg#fix{msgSeqNum = list_to_integer(binary_to_list(B))}, Tail);
fill_header(Msg, [{49,B} | Tail]) -&gt;
    fill_header(Msg#fix{senderCompID = B}, Tail);
fill_header(Msg, [{56,B} | Tail]) -&gt;
    fill_header(Msg#fix{targetCompID = B}, Tail);
fill_header(Msg, [{52,B} | Tail]) -&gt;
    fill_header(Msg#fix{sendingTime = to_timestamp(B)}, Tail);
fill_header(Msg, Fields) -&gt;
    Msg#fix{msgType = element(1, decode_msg_type(Msg#fix.msgType)),
            body = decode_msg_body(Msg#fix.msgType, Fields)}.
</xsl:text>
<xsl:for-each select="fix/messages/message">
decode_msg_body($<xsl:value-of select="@msgtype"/>, Fields) <xsl:text disable-output-escaping="yes">-&gt;</xsl:text>	decode_msg_body2($<xsl:value-of select="@msgtype"/>, #<xsl:call-template name="proper-case">
			<xsl:with-param name="str"><xsl:value-of select="@name"/></xsl:with-param>
	</xsl:call-template>{}, Fields);</xsl:for-each>
decode_msg_body(Other,_Flds) <xsl:text disable-output-escaping="yes">-&gt; throw({undef_msg_type, Other}).

decode_msg_body2(MsgType, R, [{N, B} | T]) ->
    case msg_req_field_position(MsgType, N) of
    I when is_integer(I), I =&lt; tuple_size(R)-1 -&gt;
		decode_msg_body2(MsgType, setelement(I+1, R, decode_field_value(N, B)), T);
    not_found -&gt;
        decode_msg_body2(MsgType,
            setelement(tuple_size(R), R, [{N, B} | element(tuple_size(R), R)]),
            T)
    end;
decode_msg_body2(_MsgType, R, []) ->
    R.

decode_field_value(N, Bin) ->
	decode_field_value2(element(2, decode_field(N)), Bin).
	
decode_field_value(N, Type, Bin) ->
    try
		decode_field_value2(Type, Bin)
	catch _:Error ->
		throw({{decode_field_value, N, Type, Bin}, Error})
	end.

decode_field_value2(Type, Bin) -> 
	case Type of
	'AMT'                 -> to_float(Bin);
	'ATOM'				  -> list_to_atom(binary_to_list(Bin));
	'BOOLEAN'
		when Bin=:=&lt;&lt;"Y"&gt;&gt;-&gt; true;
	'BOOLEAN'			  -> false;
	'CHAR'                -> &lt;&lt;C&gt;&gt; = Bin, C;
	'CURRENCY'            -> to_float(Bin);
	'DATA'                -> Bin;
	'DAYOFMONTH'          -> list_to_integer(binary_to_list(Bin));
	'EXCHANGE'            -> Bin;
	'FLOAT'               -> to_float(Bin);
	'INT'                 -> list_to_integer(binary_to_list(Bin));
	'LENGTH'              -> list_to_integer(binary_to_list(Bin));
	'LOCALMKTDATE'        -> Bin;
	'MONTHYEAR'           -> &lt;&lt;Y:4/binary, M:2/binary&gt;&gt; = Bin,
	                         {list_to_integer(binary_to_list(Y)),
	                          list_to_integer(binary_to_list(M))};
	'MULTIPLEVALUESTRING' -> binary_to_list(Bin);
	'PRICE'               -> to_float(Bin); 
	'PRICEOFFSET'         -> list_to_integer(binary_to_list(Bin));
	'QTY'                 -> list_to_integer(binary_to_list(Bin));
	'QUANTITY'            -> list_to_integer(binary_to_list(Bin));
	'STRING'              -> binary_to_list(Bin);
	'UTCDATE'             -> binary_to_list(Bin);
	'UTCTIMEONLY'         -> binary_to_list(Bin);
	'UTCTIMESTAMP'        -> to_timestamp(Bin)
	end.

to_float(Bin) ->
	case binary:match(Bin, &lt;&lt;$.&gt;&gt;) of
	nomatch -> list_to_integer(binary_to_list(Bin)) / 1;
	_	    -> list_to_float(binary_to_list(Bin))
	end.
	
to_timestamp(&lt;&lt;Y:4/binary,Mn:2/binary,D:2/binary,$-,H:2/binary,$:,M:2/binary,$:,S:2/binary,$.,MS:3/binary&gt;&gt;) -&gt;
	{{list_to_integer(binary_to_list(Y)),
	  list_to_integer(binary_to_list(Mn)),
	  list_to_integer(binary_to_list(D))},
	 {list_to_integer(binary_to_list(H)),
	  list_to_integer(binary_to_list(M)),
	  list_to_integer(binary_to_list(S))},
	 list_to_integer(binary_to_list(MS))*1000};
to_timestamp(&lt;&lt;Y:4/binary,Mn:2/binary,D:2/binary,$-,H:2/binary,$:,M:2/binary,$:,S:2/binary&gt;&gt;) -&gt;
	{{list_to_integer(binary_to_list(Y)),
	  list_to_integer(binary_to_list(Mn)),
	  list_to_integer(binary_to_list(D))},
	 {list_to_integer(binary_to_list(H)),
	  list_to_integer(binary_to_list(M)),
	  list_to_integer(binary_to_list(S))},
	 0};
to_timestamp(&lt;&lt;Y:4/binary,Mn:2/binary,D:2/binary,$-,H:2/binary,$:,M:2/binary,$:,S:2/binary,$.,MS:6/binary&gt;&gt;) -&gt;
	{{list_to_integer(binary_to_list(Y)),
	  list_to_integer(binary_to_list(Mn)),
	  list_to_integer(binary_to_list(D))},
	 {list_to_integer(binary_to_list(H)),
	  list_to_integer(binary_to_list(M)),
	  list_to_integer(binary_to_list(S))},
	 list_to_integer(binary_to_list(MS))}.

</xsl:text>

<xsl:variable name="MaxLength">
    <xsl:call-template name="maximum">
        <xsl:with-param name="values"
            select="fix/messages/message/@name"/>
    </xsl:call-template>
</xsl:variable>

<xsl:for-each select="fix/messages/message">
decode_msg_type($<xsl:value-of select="@msgtype"/>) <xsl:text disable-output-escaping="yes">-&gt;</xsl:text> {<xsl:call-template name="proper-case">
	<xsl:with-param name="str"><xsl:value-of select="@name"/></xsl:with-param>
</xsl:call-template>, <xsl:value-of select="@msgcat"/>};</xsl:for-each>
decode_msg_type(I)  -<xsl:text disable-output-escaping="yes">&gt;</xsl:text> {I, undefined}.

<xsl:for-each select="fix/messages/message">
encode_msg_type(<xsl:call-template name="proper-case">
	<xsl:with-param name="str"><xsl:value-of select="@name"/></xsl:with-param>
</xsl:call-template>)<xsl:call-template name="pad">
			<xsl:with-param name="padCount">
				<xsl:value-of select="$MaxLength+1 - string-length(@name)"/>
			</xsl:with-param>
		</xsl:call-template><xsl:text disable-output-escaping="yes">-&gt;</xsl:text> $<xsl:value-of select="@msgtype"/><xsl:choose>
	<xsl:when test="position() = last()">.
</xsl:when>
	<xsl:otherwise>;</xsl:otherwise>
</xsl:choose></xsl:for-each>

<!--
<xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'" />
<xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'" />

<xsl:for-each select="fix/fields/field[value]">
    <xsl:text>

%% @spec (char()) -> atom()
</xsl:text>
    <xsl:for-each select="value">
        <xsl:text>decode_</xsl:text>
        <xsl:value-of select="../@name"/>
        <xsl:text>($</xsl:text>
        <xsl:value-of select="@enum"/>
        <xsl:text disable-output-escaping="yes">) -&gt; '</xsl:text>
        <xsl:value-of select="translate(@description, $uppercase, $smallcase)"/>
        <xsl:text>';
</xsl:text>
    </xsl:for-each>
    <xsl:text>decode_</xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text disable-output-escaping="yes">(I)  -&gt; throw({invalid_</xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>, I}.</xsl:text>

    <xsl:text>
%% @spec (atom()) -> char()
</xsl:text>
    <xsl:variable name="max-len">
        <xsl:call-template name="maximum">
            <xsl:with-param name="values"
                select="value/@description"/>
        </xsl:call-template>
    </xsl:variable>

    <xsl:for-each select="value">
        <xsl:text>encode_</xsl:text>
        <xsl:value-of select="../@name"/>
        <xsl:text>('</xsl:text>
        <xsl:value-of select="translate(@description, $uppercase, $smallcase)"/>
        <xsl:text disable-output-escaping="yes">') </xsl:text>

        <xsl:call-template name="pad">
            <xsl:with-param name="padCount">
                <xsl:value-of select="$max-len + 1 - string-length(@description)"/>
            </xsl:with-param>
        </xsl:call-template>
        <xsl:text>-&gt; '</xsl:text>
        <xsl:value-of select="@enum"/>
        <xsl:text>;
</xsl:text>
    </xsl:for-each>
    <xsl:text>encode_</xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text disable-output-escaping="yes">(I) </xsl:text>
    <xsl:call-template name="pad">
        <xsl:with-param name="padCount">
            <xsl:value-of select="$max-len + 1 - 1"/>
        </xsl:with-param>
    </xsl:call-template>
    <xsl:text>  -&gt; throw({invalid_</xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>, I}.</xsl:text>
</xsl:for-each>
-->
    
<!--
<xsl:for-each select="fix/messages/message">
encode_ord_status(<xsl:call-template name="proper-case">
	<xsl:with-param name="str"><xsl:value-of select="@description"/></xsl:with-param>
</xsl:call-template>)<xsl:call-template name="pad">
			<xsl:with-param name="padCount">
				<xsl:value-of select="$MaxLength+1 - string-length(@name)"/>
			</xsl:with-param>
		</xsl:call-template><xsl:text disable-output-escaping="yes">-&gt;</xsl:text> $<xsl:value-of select="@msgtype"/><xsl:choose>
	<xsl:when test="position() = last()">.
</xsl:when>
	<xsl:otherwise>;</xsl:otherwise>
</xsl:choose></xsl:for-each>
-->
    
<xsl:for-each select="fix/messages/message">
	<xsl:for-each select="field[@required = 'Y']">
		<xsl:variable name="Field" select="@name"/>
		<xsl:variable name="Value" select="/fix/fields/field[@name = $Field]/@number"/>
		<xsl:variable name="Pos" select="count(preceding-sibling::field[@required = 'Y'])+1"/>
msg_req_field_position($<xsl:value-of select="../@msgtype"/>, <xsl:value-of select="$Value"/>)<xsl:call-template name="pad">
			<xsl:with-param name="padCount">
				<xsl:value-of select="6 - string-length(../@msgtype) - string-length($Value)"/>
			</xsl:with-param>
		</xsl:call-template><xsl:text disable-output-escaping="yes">-&gt; </xsl:text>
<xsl:value-of select="$Pos"/>;<xsl:call-template name="pad">
			<xsl:with-param name="padCount">
				<xsl:value-of select="5 - string-length('$Pos')"/>
			</xsl:with-param>
		</xsl:call-template>% <xsl:value-of select="$Field"/></xsl:for-each>
</xsl:for-each>
msg_req_field_position(_,   _) <xsl:text disable-output-escaping="yes">-&gt; not_found.
</xsl:text>

<xsl:variable name="MaxLength2">
    <xsl:call-template name="maximum">
        <xsl:with-param name="values"
            select="fix/fields/field/@name"/>
    </xsl:call-template>
</xsl:variable>

	<xsl:for-each select="fix/fields/field">
decode_field(<xsl:value-of select="@number"/>)<xsl:call-template name="pad">
		<xsl:with-param name="padCount">
			<xsl:value-of select="6 - string-length(@number)"/>
		</xsl:with-param>
    </xsl:call-template><xsl:text disable-output-escaping="yes">-&gt; </xsl:text>{<xsl:call-template name="proper-case">
			<xsl:with-param name="str"><xsl:value-of select="@name"/></xsl:with-param>
		</xsl:call-template>, '<xsl:value-of select="@type"/>'};</xsl:for-each>
decode_field(Other) <xsl:text disable-output-escaping="yes">-&gt; throw({undef_field, Other}).
</xsl:text>

<xsl:for-each select="fix/fields/field">
    <xsl:variable name="fieldName">
        <xsl:call-template name="proper-case">
			<xsl:with-param name="str"><xsl:value-of select="@name"/></xsl:with-param>
		</xsl:call-template>
    </xsl:variable>
    <xsl:variable name="padding">
		<xsl:call-template name="pad">
			<xsl:with-param name="padCount">
				<xsl:value-of select="$MaxLength2 - string-length(@name)"/>
			</xsl:with-param>
		</xsl:call-template>    
    </xsl:variable>
encode_field(<xsl:value-of select="$fieldName"/>)<xsl:value-of select="$padding"/><xsl:text disable-output-escaping="yes">-&gt; </xsl:text><xsl:value-of select="@number"/>;</xsl:for-each>
encode_field(Other)<xsl:call-template name="pad">
			<xsl:with-param name="padCount">
				<xsl:value-of select="$MaxLength2 - string-length('Other')"/>
			</xsl:with-param>
    </xsl:call-template><xsl:text disable-output-escaping="yes">-&gt; </xsl:text>throw({undef_field, Other}).

<xsl:variable name="MaxLength001">
    <xsl:call-template name="maximum">
        <xsl:with-param name="values"
            select="fix/fields/field[count(value) > 0]"/>
    </xsl:call-template>
</xsl:variable>
<xsl:variable name="MaxLength002">
    <xsl:call-template name="maximum">
        <xsl:with-param name="values"
            select="fix/fields/field[count(value) > 0]"/>
    </xsl:call-template>
</xsl:variable>
<xsl:variable name="MaxLength3" select="$MaxLength001 + $MaxLength002"/>

<xsl:for-each select="fix/fields/field">
	<xsl:variable name="fieldName" select="@name"/>
	<xsl:variable name="fieldNo" select="../field[@name = $fieldName]/@number"/>
	<xsl:choose>
		<xsl:when test="count(value) &gt; 0">
			<xsl:for-each select="value">
				<xsl:variable name="len"><xsl:call-template name="arg-value">
				<xsl:with-param name="value"><xsl:value-of select="@enum"/></xsl:with-param>
				<xsl:with-param name="type"><xsl:value-of select="../@type"/></xsl:with-param>
				</xsl:call-template></xsl:variable>
decode_value(<xsl:value-of select="$fieldNo"/>, &lt;&lt;<xsl:call-template name="arg-value">
				<xsl:with-param name="value"><xsl:value-of select="@enum"/></xsl:with-param>
				<xsl:with-param name="type"><xsl:value-of select="../@type"/></xsl:with-param>
				</xsl:call-template>&gt;&gt;)<xsl:call-template name="pad">
						<xsl:with-param name="padCount"><xsl:value-of select="20 - string-length($len) - string-length(format-number($fieldNo, '#'))"/></xsl:with-param>
				</xsl:call-template><xsl:text disable-output-escaping="yes"> -&gt; </xsl:text>'<xsl:value-of select="substring(translate(@description,
					'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 1, 50)"/>';</xsl:for-each>
		</xsl:when>
		<xsl:when test="$fieldNo = 55">
decode_value(<xsl:value-of select="$fieldNo"/>, Bin)<xsl:call-template name="pad">
						<xsl:with-param name="padCount"><xsl:value-of select="20 + 1 - string-length($fieldNo)"/></xsl:with-param>
			</xsl:call-template><xsl:text disable-output-escaping="yes"> -></xsl:text> decode_field_value(<xsl:value-of select="$fieldNo"/>, 'ATOM', Bin);</xsl:when>
		<xsl:otherwise>
decode_value(<xsl:value-of select="$fieldNo"/>, Bin)<xsl:call-template name="pad">
						<xsl:with-param name="padCount"><xsl:value-of select="20 + 1 - string-length($fieldNo)"/></xsl:with-param>
			</xsl:call-template><xsl:text disable-output-escaping="yes"> -></xsl:text> decode_field_value(<xsl:value-of select="$fieldNo"/>, '<xsl:value-of select="@type"/>', Bin);</xsl:otherwise>
	</xsl:choose>
</xsl:for-each>
decode_value(_Field, Value)<xsl:call-template name="pad">
			<xsl:with-param name="padCount"><xsl:value-of select="20 - 7"/></xsl:with-param>
</xsl:call-template><xsl:text disable-output-escaping="yes"> -&gt; </xsl:text>Value.

</xsl:template>

<xsl:template name="maximum">
    <xsl:param name="values"/>
    <xsl:for-each select="$values">
        <xsl:sort select="string-length(.)" data-type="number" order="descending"/>
        <xsl:if test="position()=1"><xsl:value-of select="string-length(.)"/></xsl:if>
    </xsl:for-each>
</xsl:template>

</xsl:stylesheet>
